# 变量

在Python中，变量是用来存储数据值的标识符。



**特点**

- Python是动态类型语言，这意味着变量的类型不需要事先声明，会根据赋值自动推断。
- 变量使用前必须赋值，变量赋值后变量才会创建。
- 变量的数据类型可以随时改变。
- 变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。



**赋值**

```python
# 单个变量赋值
n = 20

# 多个变量赋相同值
a = b = c = 1

# 多个变量赋不同值
d, e, f = 5, 6, 7
g, h, k = [5, 6, 7]
```



**删除**

```python
x = 1
del x
```



**交换**

```python
a, b = 1, 2
a, b = b, a
```





# 数据类型

## 内置数据类型

1. 空对象：None
2. 数字
   1. 整数：int
      1. 布尔：bool
   2. 浮点数：float
   3. 复数：complex
3. 序列
   1. 字符串：str
   2. 数字：range
   3. 列表、元组：list、tuple
   4. 二进制
      1. 不可变二进制序列：bytes
      2. 可变二进制序列：bytearray
      3. 内存视图：memoryview
4. 集合：
   1. 集合：set
   2. 不可变集合：frozenset
5. 映射
   1. 字典：dict
6. 其他
   1. 类与类实例：class
   2. 函数：function



> 布尔值属于整数的子类型，数值计算时，True 被当作 1，False 被当作 0。



[内置类型 — Python 3.8.19 文档](https://docs.python.org/zh-cn/3.8/library/stdtypes.html?highlight=内置#other-built-in-types)



| 类型       | 有序性 | 可变性 | 重复性   |
| ---------- | ------ | ------ | -------- |
| str        | 有序   | 不可变 | 可重复   |
| range      | 有序   | 不可变 | 可重复   |
| list       | 有序   | 可变   | 可重复   |
| tuple      | 有序   | 不可变 | 可重复   |
| byte       | 有序   | 不可变 | 可重复   |
| bytearray  | 有序   | 可变   | 可重复   |
| memoryview | 有序   | 不可变 | 可重复   |
| set        | 无序   | 可变   | 不可重复 |
| frozenset  | 无序   | 不可变 | 不可重复 |
| dict       | 无序   | 可变   | 不可重复 |



## 数据类型判断

### type

传入一个参数时，返回 *object* 的类型。 返回值是一个 type 对象，通常与`object.__class__`所返回的对象相同。

```python
i = 1
print(type(i))  # <class 'int'>
print(i.__class__)  # <class 'int'>
print(type(type(i)))  # <class 'type'>
```



```python
print(type(None))  # <class 'NoneType'>
print(type(True))  # <class 'bool'>
print(type(2))  # <class 'int'>
print(type(3.5))  # <class 'float'>
print(type(1 + 2j))  # <class 'complex'>
print(type("python"))  # <class 'str'>
print(type(range(3)))  # <class 'range'>
print(type([1, 2]))  # <class 'list'>
print(type((1, 2)))  # <class 'tuple'>
print(type(b"python"))  # <class 'bytes'>
print(type(bytearray(b"python")))  # <class 'bytearray'>
print(type(memoryview(b"python")))  # <class 'memoryview'>
print(type({1, 2}))  # <class 'set'>
print(type(frozenset([1, 2])))  # <class 'frozenset'>
print(type({"name": "koobro"}))  # <class 'dict'>
```



```python
class A:
    pass

a = A()

print(type(A))  # <class 'type'>
print(type(a))  # <class '__main__.A'>


def func():
    pass


print(type(func))  # <class 'function'>
```





### isinstance

**基本用法**

`isinstance(object, classinfo)`，其中 `object` 是你想要检查的对象，`classinfo` 可以是一个类型或者是一个类型元组。如果 `object` 是 `classinfo` 或其子类的实例，则返回 `True`，否则返回 `False`。

推荐使用 `isinstance()` 内置函数来检测对象的类型，因为它会考虑子类的情况。

```python
class A:
    pass


class B(A):
    pass


print(isinstance(A(), A))  # True
print(isinstance(B(), A))  # True

print(type(A()) == A)  # True
print(type(B()) == A)  # False

print(isinstance(A, object))  # True
```



```python
# print(isinstance(None, None))  # 无法检测空对象。TypeError: isinstance() arg 2 must be a type or tuple of types

print(isinstance(True, bool))  # True
print(isinstance(2, int))  # True
print(isinstance(3.5, float))  # True
print(isinstance(1 + 2j, complex))  # True
print(isinstance('python', str))  # True
print(isinstance(range(3), range))  # True
print(isinstance([1, 2], list))  # True
print(isinstance((1, 2), tuple))  # True
print(isinstance(b'python', bytes))  # True
print(isinstance(bytearray(b'python'), bytearray))  # True
print(isinstance(memoryview(b'python'), memoryview))  # True
print(isinstance({1, 2}, set))  # True
print(isinstance(frozenset([1, 2]), frozenset))  # True
print(isinstance({'name': 'koobro'}, dict))  # True
```



```python
def func():
    pass


print(type(func))  # <class 'function'>
print(isinstance(func, object))  # True
```





### type、object和class的关系

在Python中，`type`, `object`, 和 `class` 三者之间的关系是理解Python面向对象编程模型的关键。下面是这些概念及其关系的简化解释：

1. **object**:
   - `object` 是Python中所有类的基类。这意味着，不论你定义的类是否显式地继承自任何类，它们都会隐式地继承自 `object`。
   - `object` 实例化后就是一个对象，它是所有对象的超类，提供了最基本的方法，如 `__str__`, `__repr__`, `__eq__` 等。
   - `object` 类本身没有父类，位于类继承树的顶端。

2. **type**:
   - `type` 是一个特殊的类，它负责创建所有的类对象。换句话说，`type` 是类的类，也就是元类（metaclass）。
   - `type` 本身也是一个对象，并且它也是一个 `object` 的子类，这意味着 `type` 也遵循一切皆对象的原则。
   - 当你定义一个类时，如 `class MyClass: pass`，实际上 `MyClass` 这个类对象就是由 `type` 创建的。即，`type(MyClass)` 会告诉你 `MyClass` 的类型是 `<class 'type'>`。
   - `type` 也可以用来动态创建类，比如 `MyDynamicClass = type('MyDynamicClass', (object,), {'attr': 42})`。

3. **class**:
   - 在Python中，当我们提到 "class"，通常指的是用户定义的类，比如前面例子中的 `MyClass`。这些类是由 `type` 创建的实例，因此它们都是 `type` 的对象。
   - 每个用户定义的类自动继承自 `object`（除非明确指定其他基类），这使得它们能够继承 `object` 的所有属性和方法。
   - 类定义体中的代码（如方法定义）在类被创建时执行，而类的实例则是通过调用类这个对象（实际上是 `type` 的实例）来创建的，例如 `my_instance = MyClass()`。

总结一下，`object` 是所有对象的基础，`type` 是创建所有类的工厂，包括它自己（`type` 也是由 `type` 创建的），而用户定义的类（`class`）是 `type` 的实例，并且默认继承自 `object`。这样，Python中的一切，包括类本身，都是对象，体现了“一切皆对象”的哲学。



```python
s = "hello"


class Student:
    pass


stu = Student()


def func():
    pass


# str
print(type(s))  # <class 'str'>
print(type(str))  # <class 'type'>
print(str.__base__)  # <class 'object'>
print(object.__base__)  # None
print(type(object))  # <class 'type'>
print(type(type))  # <class 'type'>
print(type.__base__)  # <class 'object'>

# class
print(type(stu))  # <class '__main__.Student'>
print(type(Student))  # <class 'type'>
print(Student.__base__)  # <class 'object'>

# function
print(type(func))  # <class 'function'>
print(type(type(func)))  # <class 'type'>
print(type(func).__base__)  # <class 'object'>
```





## 数字

### 整数

Python中的整数（`int` 类型）是一种用于表示没有小数部分的数字的数据类型。



**不可变性**

整数是不可变数据类型，意味着一旦创建了一个整数，就不能改变它的值。对整数的操作会创建新的整数实例，而不是修改原值。

```python
a = 1
print(id(a))  # 140729445521168

a = 2
print(id(a))  # 140729445521200
```



**无限精度**

Python的整数类型支持无限精度，这意味着可以表示非常大或非常小的整数，理论上仅受可用内存限制。

没有一个固定的“最大整数”常量，如在某些其他编程语言中那样。不能直接通过如 `sys.maxint`（这是Python 2中的做法）来获取最大整数，因为在Python 3中，这样的概念已被移除。



**进制表示**

- 十进制：默认的表示形式，直接写数字即可，如 `42`。

- 二进制：以 `0b` 或 `0B` 开头，如 `0b1010` 表示十进制中的 `10`。

- 八进制：以 `0o` 或 `0O` 开头，如 `0o12` 表示十进制中的 `10`。

- 十六进制：以 `0x` 或 `0X` 开头，如 `0xA` 表示十进制中的 `10`。



**类型转换**

可以使用 `int()` 函数将其他类型（如字符串或浮点数）转换为整数，但转换时需要注意，如果源数据不是整数形式或无法无损转换（如浮点数转整数），可能会引发错误或丢失精度。

1. **从字符串转换**：
   如果字符串是一个有效的整数表示（可选地包括正负号和进制指示符），`int()` 可以直接将其转换为整数。

```python
num_str = "123"
num = int(num_str)  # num 现在是整数 123
```

2. **包含进制的字符串转换：**

```python
hex_str = "0xFF"
num_hex = int(hex_str, 16)  # num_hex 是十进制的 255
bin_str = "0b1010"
num_bin = int(bin_str, 2)  # num_bin 是十进制的 10
```

3. **从浮点数转换**：
   将浮点数转换为整数时，`int()` 会进行舍去小数部分的转换（即下取整）。

```python
float_num = 3.14
int_num = int(float_num)  # int_num 是 3
```



注意事项

- 如果提供的字符串不能被解释为一个整数，`int()` 会抛出 `ValueError` 异常。
- 当从浮点数转换为整数时，可能丢失精度。

确保在尝试转换之前，确认转换操作是有意义的，并且能够安全地进行，避免潜在的错误或数据丢失。





### 浮点数

```python
# 1.0等价于1
print(1.0 == 1)  # True

# 小数点第2位开始如果都是0，则省略不输出
print(3.10)  # 3.1

# 转换
print(float('2.3'))  # 2.3

# 科学计数法
print(2.3456 ** 55)  # 2.3118913116655744e+20
```



**精度问题**

Python中的浮点数精度问题源于IEEE 754浮点数标准的实现，该标准被大多数现代编程语言采用，包括Python。根据这个标准，浮点数是以二进制形式存储的，这导致了一些十进制小数无法精确表示。

当你尝试计算 `0.1 + 0.2` 时，实际上得到的是一个非常接近但不完全等于 `0.3` 的浮点数。这种微小的差异在直接与 `0.3` 比较时就会显现出来，导致 `0.1 + 0.2 == 0.3` 返回 `False`。

```python
print(0.1 + 0.2 == 0.3)  # False
```

解决或减轻这种精度问题的方法有几种：

1. **使用 `decimal` 模块**：Python 的 `decimal` 模块提供了一种进行高精度浮点数算术的方法，可以避免二进制浮点数的精度问题。
   
   ```python
   from decimal import Decimal
   
   print(Decimal('0.1') + Decimal('0.2') == Decimal('0.3'))  # True
   ```
   
2. **使用 `fractions` 模块**：对于分数形式的数字，可以使用 `fractions` 模块来保持精确度。
   
   ```python
   from fractions import Fraction
   
   print(Fraction(1, 10) + Fraction(2, 10) == Fraction(3, 10))  # True
   ```
   
3. **容差比较**：如果知道计算中可能会有微小的误差，可以定义一个很小的容差值（比如 `1e-9`），然后比较两个浮点数是否在该容差范围内相等。
   
   ```python
   epsilon = 1e-9
   print(abs(0.1 + 0.2 - 0.3) < epsilon)  # True
   ```

了解浮点数的这一特性对于编写涉及精确计算的Python程序非常重要。在需要高精度计算的场景下，推荐使用`decimal`或`fractions`模块。







### 布尔

在Python中，布尔类型是一种特殊的类型，它只有两个值：`True` 和 `False`，这两个值主要用于逻辑判断。



**内置对象**

下面列出了会被视为假值的内置对象：

- 常量：`None`、`False`。
- 任何数值类型的零：`0`、`0.0`、`0j`、`Decimal(0)`、`Fraction(0, 1)`。
- 空的序列和多项集：`''`、`""`、`''''''`、`""""""`、`[]`、`()`、`{}`、`set()`、`range(0)`。

```python
flag = any([None, False, 0, 0.0, 0j, '', "", """""", '''''', [], (), {}, set(), range(0)])
print(flag)
```



**运算符**

布尔类型在Python中主要与以下运算符紧密相关：

- **逻辑运算符**

- **比较运算符**
  - （虽然严格意义上它们不直接产生布尔值，但通常与布尔逻辑结合使用紧密）：这些比较运算符用于比较两个值，其结果是一个布尔值，表示比较的结果是True还是False。

在实际编程中，这些逻辑和比较运算符常被用于条件语句（如if语句）、循环控制以及逻辑表达式的构建中，以实现复杂的逻辑判断和流程控制。





**为什么布尔属于整数类型？**

在Python中，布尔类型(True和False)在某些上下文中可以被视为整数类型的一个子集。具体来说：

- `True` 的值在需要整数的上下文中会被自动转换为 `1`。
- `False` 的值在同样的情况下会被转换为 `0`。

这种行为是因为Python的设计者选择让布尔类型与整数类型有一定的兼容性，这在某些数学或逻辑运算中非常有用。例如，在进行算术运算或集合操作时，布尔值可以无缝参与。

```python
print(True + 1)  # 输出: 2
print(False * 5) # 输出: 0
```

尽管如此，从类型系统角度来看，布尔型仍然是一个独立的类型，不是整型的直接子类。这意味着你不能直接将布尔类型与整数类型互换使用在所有场景，尤其是在类型检查严格的上下文中。布尔型更多地被视为逻辑值，而整型则用于数值计算和表示数量。这种兼容性主要是为了方便和实用性，并体现了Python设计中“鸭子类型”哲学的一部分——关注对象的行为而非其类型。







## 字符串

字符串可以使用双引号`""`，也可以使用单引号`''`。两者在大多数情况下可互换使用，根据个人偏好或字符串内部是否包含特定引号来选择。



### 创建和添加字符串

1. 单引号与双引号

最常见的创建字符串的方式。
```python
s1 = "Hello, World!"
```


2. 三引号构造多行字符串

三引号 (`'''` 或 `"""`) 允许创建跨多行的字符串，同时保留文本中的换行符和缩进，非常适合编写文档注释或长段落文本：
```python
s2 = """Hello 
World
This is a multiline string."""
```



3. 原始字符串：禁用转义

原始字符串字面量通过在字符串前添加 `r` 或 `R` 前缀，可以避免解释器解析其中的任何转义字符，这对于包含路径等特殊字符的字符串非常有用：
```python
s = r"C:\Users\Alice\Documents"
```



4. 数据类型转换为字符串

利用 `str()` 函数，可以将其他数据类型（如整数、浮点数等）转换成字符串形式：
```python
s3 = str(2)       # 结果: "2"
s4 = str(2.5)     # 结果: "2.5"
```



5. 使用 `join()` 方法构造字符串

`join()` 方法是将字符串列表中的元素合并成一个字符串的有效手段，元素间以指定的分隔符连接：

```python
s8 = " ".join(["Hello", "World"])  # 结果: "Hello World"
```



6. 使用运算符

```python
str1 = "Hello, "
str2 = "World!"

print(str1 + str2)  # Hello, World!
str1 += str2
print(str1)  # Hello, World!
print(str1 * 2)  # Hello, World!Hello, World!
```



### 单双引号共存问题

当在Python中同时需要使用单引号(`'`)和双引号(`"`)来界定字符串，并且字符串内部也需要包含这两种引号时，需要注意以下几点，以避免语法错误和正确闭合字符串：

1. **交错使用**：如果一个字符串中需要包含另一种界定符，可以选择交错使用单引号和双引号来包围整个字符串。例如，如果你的字符串中需要包含双引号，你可以使用单引号来界定这个字符串，反之亦然。
   ```python
   s1 = 'He said, "Hello, World!"'
   s2 = "It's a beautiful day, isn't it?"
   ```

2. **转义字符**：如果必须在同一对引号中使用相同的引号，可以使用反斜杠(`\`)作为转义字符，来告诉Python该字符是文字字符，不应作为字符串界定符处理。
   ```python
   s3 = "She said, \"I'm coming.\""
   s4 = 'The path is "C:\\Users\\Alice\\Documents".'
   ```

3. **三引号多行字符串**：在多行字符串(`'''`或`"""`)中，由于其自身的包容性，可以直接包含单引号和双引号而无需转义，这为包含多种引号的文本提供了便利。
   
   ```python
   s5 = """He said, "Don't forget," and then added, 'Remember the quotes.'"""
   ```
   
4. **原始字符串字面量**：虽然原始字符串主要用于禁用转义序列，但如果字符串中需要原样包含引号而不转义，且不涉及其他需要转义的字符时，也可以考虑使用原始字符串字面量，但要注意原始字符串不能直接解决单双引号嵌套问题。
   

总之，在处理包含单双引号的字符串时，交错使用引号类型或适当使用转义字符是关键。正确运用这些规则，可以确保你的代码逻辑清晰且无语法错误。





### 转义字符

在Python中，你可以使用转义字符来插入特殊字符到字符串中。以下是一些常见的转义字符：

- `\n`：换行
- `\r`：回车
- `\t`：制表符
- \b：退格
- `\`：反斜杠
- `'`：单引号
- `"`：双引号
- `\`：反引号

\r、\n、以及\r\n的区别在于它们代表不同的换行符：

- \n：在Linux系统中使用，称为LF（Line Feed）
- \r\n：在Windows系统中使用，称为CRLF（Carriage Return Line Feed）
- \r：在Mac系统中使用，称为CR（Carriage Return） 如果你想在字符串中使用这些字符而不让它们被解析为转义字符，你可以在字符串前加上r前缀，这将创建一个原始字符串。



```python
print("Hello\nWorld")  # Hello （换行） World
print("Hello\\nWorld")  # Hello\nWorld
print(r"Hello\nWorld")  # Hello\nWorld
```



### 使用字符串

```python
# 索引
s[0]  # 默认从0开始。
s[-1] # 负数索引从字符串末尾开始计数

# 切片
s[0:5]  # 索引截止位置是开区间，不包含结束位置
s[7:]   # 省略结束索引则提取至字符串末尾

# 元素个数
s.count("a")

# 查找
s.find("o", 0, -1) # 从左边开始查找，如果找到了子字符串，则返回子字符串第一次出现的位置的索引，如果找不到则返回 -1。
s.rfind("o", 0, -1) # 从右边开始查找，如果找到了子字符串，则返回子字符串最后一次出现的位置的索引，如果找不到则返回 -1。
s.index("o", 0, -1) # 从左边开始查找，如果找到了子字符串，则返回子字符串第一次出现的位置的索引，如果找不到则抛出 ValueError 异常。
s.rindex("o", 0, -1) # 从右边开始查找，如果找到了子字符串，则返回子字符串最后一次出现的位置的索引，如果找不到则抛出 ValueError 异常。

# 大小写转换
s.capitalize()  # 首字母大写
s.upper()  # 转大写
s.lower()  # 转小写
s.swapcase()  # 大小写互转
s.title()  # 所有单词转为首字母大写

# 去除空格
s.strip()  # 去除前后空格
s.lstrip()  # 去除前空格
s.rstrip()  # 去除后空格

# 填充
s.rjust(20, "*")  # 左填充
s.ljust(20, "*")  # 右填充
s.center(20, "*")  # 中间填充
s.zfill(20)  # 全填充

# 替换
s.expandtabs(2) # 将tab替换成空格
s.replace("love", "Like")  # 替换子串
s.translate(s.maketrans("lo", "ab"))  # 创建字符映射的转换表，替换转换表中的对应字符

# 拆分
s.split(" ")  # 根据空格拆分所有子串，返回列表
s.rsplit(" ")  # 根据空格拆分所有子串，返回列表，从右边开始拆分
s.splitlines()  # 根据换行符拆分
s.partition(" ")  # 根据 sep 首次出现位置拆分，返回元组：分隔符之前的部分、分隔符本身，以及分隔符之后的部分
s.rpartition(" ")  # 根据 sep 首次出现位置拆分，返回元组：分隔符之前的部分、分隔符本身，以及分隔符之后的部分，从右边开始拆分

# 判断
s.isupper()  # 判断字符串是否全为大写
s.islower()  # 判断字符串是否全为小写
s.istitle()  # 判断字符串是否为标题形式（每个单词首字母大写）
s.startswith("H")  # 判断字符串是否以指定字符开头
s.endswith("d")  # 判断字符串是否以指定字符结尾
s.isdigit()  # 判断字符串是否只包含数字
s.isnumeric()  # 判断字符串是否为数值类型
s.isalpha()  # 判断字符串是否只包含字母
s.isalnum()  # 判断字符串是否只包含字母或数字
s.isdecimal()  # 判断字符串是否为十进制数字
s.isspace()  # 判断字符串是否只包含空格
s.isascii()  # 判断字符串是否只包含 ASCII 字符
s.isidentifier()  # 判断字符串是否为有效的标识符
s.isprintable()  # 判断字符串是否为可打印字符

```







### 格式化字符串



#### f-string

自Python 3.6起，f-string（格式化字符串字面量）成为了一种简洁、直观的字符串内插表达方式，它允许直接在字符串中嵌入表达式，并在运行时动态替换。



- **基本使用**

f-string以 `f` 或 `F` 前缀开头，之后在花括号 `{}` 内放入你想要插入的表达式。

```python
name = "Alice"
age = 30
s5 = f"My name is {name} and I am {age} years old."  # 动态生成字符串
```



- **表达式支持**

f-string中的表达式可以是变量名、复杂表达式甚至是函数调用。

```python
import math

radius = 5
area = math.pi * radius ** 2
info = f"The area of a circle with radius {radius} is {area:.2f}."
print(info)  # 输出: The area of a circle with radius 5 is 78.54.
```



- **格式控制**

```python
# 数字格式化。使用 : 后跟格式说明符，如 .2f 表示保留两位小数的浮点数格式。
value = 3.14159
formatted = f"The value is {value:.3f}."
print(formatted)  # 输出: The value is 3.142.

# 字符串格式化：可以使用 !r 或 !s 来调用 repr() 或 str() 函数，或者直接指定其他格式，如 :{width} 控制定宽。
name = "Alice"
f_repr = f"Using repr: {name!r}, using str: {name!s}"
print(f_repr)  # 输出: Using repr: 'Alice', using str: Alice
```





- **多行f-string**

f-string同样支持多行字符串，可以使用三引号(`"""`)定义多行字符串，保持f-string的特性。

```python
long_text = f"""
Hello {name},
This is a multi-line
formatted string example.
You are {age} years old.
"""
print(long_text)
```



#### str.format()

`str.format()` 是Python中另一种强大的字符串格式化方法，它在Python 2.6中引入，并在Python 3中被广泛使用，直到f-string的出现。尽管f-string更加简洁和直观，`str.format()` 依然因其灵活性和在旧代码中的广泛存在而重要。这种方法通过在字符串中放置占位符（用大括号 `{}` 包围），并在字符串后调用 `format()` 方法传递相应的参数来填充这些占位符。



- 基本用法

```python
name = "Alice"
age = 30
formatted_str = "My name is {} and I am {} years old.".format(name, age)
print(formatted_str)  # 输出: My name is Alice and I am 30 years old.
```



- 索引和关键字参数

  - **索引**：占位符可以指定位置索引来对应传入参数的顺序。

  - **关键字参数**：通过指定参数名，可以自由调整参数的顺序。


```python
formatted_str = "{1} is {0} years old.".format(age, name)
print(formatted_str)  # 输出: 30 is Alice years old.

formatted_str = "{name} is {age} years old.".format(name=name, age=age)
print(formatted_str)  # 输出: Alice is 30 years old.
```



- 格式控制

与f-string类似，`str.format()` 也支持格式控制，通过在冒号 `:` 后添加格式规范来实现。

```python
pi = 3.14159
formatted_pi = "The value of pi is approximately {:.3f}.".format(pi)
print(formatted_pi)  # 输出: The value of pi is approximately 3.142.
```



- 属性和方法调用

可以在占位符中直接调用对象的属性或方法。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Bob", 25)
formatted_info = "Name: {obj.name}, Age: {obj.age}".format(obj=person)
print(formatted_info)  # 输出: Name: Bob, Age: 25
```

尽管f-string在很多场景下更方便，但`str.format()` 提供了额外的灵活性，特别是在需要更复杂的格式化选项或动态构建格式字符串时。





### 编码解码

在Python中，`字符串编码和解码`涉及到字符与字节之间的转换，这对于处理文本文件、网络通信等场景尤为重要。Python默认使用Unicode（通常为UTF-8）进行字符串处理，但有时需要与其他编码格式交互，如ASCII、GBK等。



- 编码（字符串转字节）

编码是将字符串转换为字节串的过程，以便于存储或在网络中传输。使用`encode()`方法可以完成这一操作。你需要指定编码格式作为参数。

```python
# 示例：将字符串编码为UTF-8字节串
utf8_bytes = "你好，世界!".encode("utf-8")
print(utf8_bytes)  # 输出：b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8c\xe4\xb8\x96\xe7\x95\x8c!'

# 示例：将字符串编码为GBK字节串
gbk_bytes = "你好，世界!".encode("gbk")
print(gbk_bytes)  # 输出：b'\xc4\xe3\xba\xc3\xa3\xac\xca\xc0\xbd\xe7!'
```



- 解码（字节串转字符串）

解码则是将字节串转换回字符串的过程，同样需要指定正确的编码格式。使用`decode()`方法完成解码。

```python
# 假设我们有一个UTF-8编码的字节串
utf8_encoded = b"\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8c\xe4\xb8\x96\xe7\x95\x8c!"

# 解码回字符串
decoded_string = utf8_encoded.decode("utf-8")
print(decoded_string)  # 输出：你好，世界!

# 如果字节串是GBK编码
gbk_encoded = b"\xc4\xe3\xba\xc3\xa3\xac\xca\xc0\xbd\xe7!"

# 解码回字符串
correct_string = gbk_encoded.decode("gbk")
print(correct_string)  # 输出：你好，世界!

# 错误解码
err_string = utf8_encoded.decode("gbk")
print(err_string)  # 输出：UnicodeDecodeError: 'gbk' codec can't decode byte 0x8c in position 14: illegal multibyte sequence
```



**注意事项**

- 在进行编码或解码时，务必确保使用的编码格式与数据的实际编码格式相匹配，否则会引发`UnicodeDecodeError`或`UnicodeEncodeError`。
- 当处理外部数据（如文件或网络数据）时，最好明确知道其编码格式。如果不明确，可能需要尝试不同的编码格式或使用一些工具来检测编码。
- Python 3中，字符串是以Unicode表示的，而字节串（bytes类型）用于存储原始的二进制数据，包括经过编码的文本。





在Python中，`字符转换`通常指的是字符编码的转换（如上所述的编码和解码过程），以及字符类型的转换，比如将字符转换为整数（ASCII值）的转换。下面简要介绍这些转换操作：

- 字符到ASCII值

使用`ord()`函数可以将单个字符转换为其对应的ASCII值。

```python
ascii_value = ord('A')
print(ascii_value)  # 输出 65
```

- ASCII值到字符

使用`chr()`函数可以将ASCII值转换回字符。

```python
character = chr(65)
print(character)  # 输出 'A'
```







## 数字序列

在Python中，`range()` 函数是一个非常有用的工具，用于生成一个数字序列，常用于循环结构中控制迭代次数。从Python 3开始，`range()` 返回的是一个可迭代的对象（`range` 对象），而不是列表。这使得它在处理大量数据时更加高效和内存友好。



**基本用法**

`range()` 可以接受0到3个参数：

1. **range(stop)**：生成从0开始到`stop`前一个数的整数序列。
   ```python
   numbers = range(5)
   print(list(numbers))  # 输出: [0, 1, 2, 3, 4]
   ```

2. **range(start, stop)**：生成从`start`开始到`stop`前一个数的整数序列。
   ```python
   numbers = range(2, 6)
   print(list(numbers))  # 输出: [2, 3, 4, 5]
   ```

3. **range(start, stop, step)**：生成从`start`开始，每次增加`step`，直到但不包括`stop`的序列。`step`可以是正数也可以是负数。
   ```python
   numbers = range(1, 10, 2)
   print(list(numbers))  # 输出: [1, 3, 5, 7, 9]
   
   numbers = range(10, 0, -2)
   print(list(numbers))  # 输出: [10, 8, 6, 4, 2]
   ```



**特点**

- **不包含结束值**：无论何时，`range()` 生成的序列都不包含`stop`值。
- **步长为1的默认值**：如果不提供`step`参数，默认步长为1。
- **内存高效**：因为 `range()` 返回的是一个迭代器，它不会立即创建完整的数字列表，这在处理大范围序列时尤其节省内存。
- **可用于循环**：直接在`for`循环中使用`range()`可以控制循环次数。





**实际应用**

`range()` 常见于循环结构中，用于计数、遍历特定范围的数字等。

```python
for i in range(5):
    print(i)  # 打印出0到4的数字

# 或者用于创建列表、生成器等
squares = [x**2 for x in range(1, 6)]
print(squares)  # 输出: [1, 4, 9, 16, 25]
```

总之，`range()` 函数是Python中处理数字序列的一个核心工具，它在循环控制、数组初始化、算法实现等方面有着广泛的应用。





## 列表







# 运算符

Python中有很多运算符，它们用于执行各种操作。以下是一些主要的Python运算符类别及其例子：

1. **算术运算符**：用于进行基本的数学运算。
   - `+` 加法：`5 + 3`
   - `-` 减法：`5 - 3`
   - `*` 乘法：`5 * 3`
   - `/` 除法（返回浮点数）：`7 / 3`
   - `//` 整除（返回整数结果）：`7 // 3`
   - `%` 取模（余数）：`7 % 3`
   - `**` 幂运算：`2 ** 3`

2. **比较运算符**：用于比较值，返回布尔值（True或False）。
   - `==` 等于：`5 == 3` （False）
   - `!=` 不等于：`5 != 3` （True）
   - `<` 小于：`5 < 3` （False）
   - `>` 大于：`5 > 3` （True）
   - `<=` 小于等于：`5 <= 3` （False）
   - `>=` 大于等于：`5 >= 3` （True）

3. **赋值运算符**：用于给变量赋值或修改变量的值。
   - `=` 赋值：`x = 5`
   - `+=` 加法赋值：`x += 3` 相当于 `x = x + 3`
   - `-=` 减法赋值：`x -= 3`
   - `*=` 乘法赋值：`x *= 3`
   - `/=` 除法赋值：`x /= 3`
   - `%=`, `**=`, `//=`, `&=`, `|=`, `^=`, `>>=`, `<<=`,`:=` 分别对应取模、幂、整除、按位与、按位或、按位异或、右移、左移赋值运算、海象运算符。

4. **逻辑运算符**：用于组合多个布尔表达式。
   - `and` 逻辑与：`True and False` （False）
   - `or` 逻辑或：`True or False` （True）
   - `not` 逻辑非：`not True` （False）

5. **成员运算符**：用于检查一个值是否在序列中。
   - `in` 成员：`'a' in 'abc'` （True）
   - `not in` 非成员：`'d' not in 'abc'` （True）

6. **身份运算符**：用于比较两个对象的身份（是否是同一个对象）。
   - `is` 身份：`x is y`
   - `is not` 非身份：`x is not y`

7. **位运算符**：对二进制数据进行操作。
   - `&` 按位与
   - `|` 按位或
   - `^` 按位异或
   - `~` 按位取反（一元运算符）
   - `<<` 左移
   - `>>` 右移





