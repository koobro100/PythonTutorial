# 多线程 threading

Python中的多线程是一种实现并发执行多个任务的技术。

在 CPython 解释器中，全局解释器锁（Global Interpreter Lock, GIL）的存在，多线程并不能实现真正的并行计算（即同一时间在多个CPU核心上执行Python字节码），如果你想让你的应用更好地利用多核心计算机的计算资源，推荐你使用`multiprocessing`或 `concurrent.futures.ProcessPoolExecutor`。 

但它仍然适用于以下场景：

1. **I/O密集型任务**：当程序的主要瓶颈在于等待输入输出操作（如文件读写、网络请求等）时，多线程可以有效提升效率。在等待I/O操作完成时，线程可以被挂起，让其他线程继续执行，从而提高整体的响应速度。

2. **异步任务处理**：多线程可以用来处理后台任务或非阻塞式操作，使得用户界面或其他任务可以保持流畅。



Python提供了几个关键模块来支持多线程编程：

- **`threading`模块**：这是Python中最常用的线程管理模块，提供了Thread类来创建线程，Lock、RLock、Condition等类来进行线程间的同步，以及Queue（队列）类来实现线程安全的数据交换。在较低级的模块 `_thread` 基础上建立较高级的线程接口。

- **`queue`模块**：提供线程间通信的安全队列，包括FIFO（先进先出）、LIFO（后进先出）和优先级队列。

- **线程同步工具**：为了防止数据竞争和不一致，可以使用锁（Lock）、信号量（Semaphore）、条件变量（Condition）等同步原语来控制线程对共享资源的访问。

几点注意：

- **GIL的影响**：由于GIL的存在，即使在多核处理器上，Python的纯Python代码也通常不会看到CPU并行处理带来的性能提升。对于计算密集型任务，多进程（multiprocessing模块）或者使用其他没有GIL限制的语言（如C扩展）可能是更好的选择。

- **上下文切换开销**：频繁的线程上下文切换可能会引入额外的性能开销，因此合理设计线程数量和任务分配至关重要。

- **死锁与竞态条件**：编写多线程程序时，要特别小心处理资源的竞争，避免出现死锁和竞态条件等问题。

- **守护线程**：Python中的线程可以设置为守护线程（daemon），这意味着当主线程结束时，守护线程也会自动终止，无需手动管理。

理解并正确运用这些概念和工具，可以帮助你在Python中有效地利用多线程编程。



## 函数和常量

这个模块定义了以下关键函数和常量，用于管理和控制线程操作：

1. **threading.active_count()**
   - 返回当前存活的 Thread 对象数量，与 `enumerate()` 函数输出的列表长度相同。
2. **threading.current_thread()**
   - 返回当前执行线程的 Thread 对象。若线程非 threading 模块创建，则返回一个受限的虚拟线程对象。
3. **threading.excepthook(args, /)**
   - 处理由 `Thread.run()` 方法引发且未被捕获的异常。`args` 参数包含异常类型、值、回溯信息及引发异常的线程。可重载此函数以自定义异常处理，注意避免由此产生的引用循环和线程复活问题。
4. **threading.get_ident()**
   - 返回当前线程的唯一标识符，为非零整数，用于如线程数据存储的场景。
5. **threading.get_native_id()**
   - 提供当前线程的系统原生ID，适用于需要跨进程唯一识别线程的情况。支持平台包括Windows、FreeBSD、Linux等。
6. **threading.enumerate()**
   - 列表形式返回所有当前活动的 Thread 对象，涵盖守护线程、主线程及虚拟线程。
7. **threading.main_thread()**
   - 特指程序启动时创建的主线程对象。
8. **threading.settrace(func)**
   - 为threading模块起始的所有线程设置跟踪函数，函数会在每个线程的 `run()` 调用前应用。
9. **threading.setprofile(func)**
   - 同上，但设置的是性能分析函数。
10. **threading.stack_size([size])**
    - 查询或设置新线程的堆栈大小。支持的平台包括Windows和具备POSIX线程的系统。
11. **threading.TIMEOUT_MAX**
    - 表示阻塞函数（如 `Lock.acquire()`, `RLock.acquire()`, `Condition.wait()` 等）中可接受的最大超时时间，超过此值将引发 `OverflowError`。

这些函数和常量共同构成了Python中使用threading模块进行多线程编程的基础工具集。



## 线程本地数据

线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 local （或者一个子类型）的实例并在实例中储存属性：

```python
mydata = threading.local()
mydata.x = 1
```

在不同的线程中，实例的值会不同。



```python
import threading

# 定义一个ThreadLocal对象
thread_local_data = threading.local()


def worker(num):
    # 为当前线程设置数据
    thread_local_data.value = num
    print(f"Thread {threading.current_thread().name}: value = {thread_local_data.value}")


# 创建并启动几个线程
threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

# 等待所有线程完成
for t in threads:
    t.join()

# 注意：这里不能直接访问thread_local_data.value，因为它在主线程中没有被赋值

"""
Thread Thread-1: value = 0
Thread Thread-2: value = 1
Thread Thread-3: value = 2
Thread Thread-4: value = 3
Thread Thread-5: value = 4
"""
```



## 线程对象 Thread

当线程对象一旦被创建，其活动必须通过调用线程的 start() 方法开始。 这会在独立的控制线程中发起调用 run() 方法。

一旦线程活动开始，该线程会被认为是 '存活的' 。当它的 run() 方法终结了（不管是正常的还是抛出未被处理的异常），就不是'存活的'。 is_alive() 方法用于检查线程是否存活。

其他线程可以调用一个线程的 join() 方法。这会阻塞调用该方法的线程，直到被调用 join() 方法的线程终结。

线程有名字。名字可以传递给构造函数，也可以通过 name 属性读取或者修改。

如果 run() 方法引发了异常，则会调用 threading.excepthook() 来处理它。 在默认情况下，threading.excepthook() 会静默地忽略 SystemExit。

一个线程可以被标记成一个“守护线程”。 这个标志的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 这个标志可以通过 daemon 特征属性或者 daemon 构造器参数来设置。

注解 守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如： Event。
有个 "主线程" 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。

"虚拟线程对象" 是可以被创建的。这些是对应于“外部线程”的线程对象，它们是在线程模块外部启动的控制线程，例如直接来自C代码。虚拟线程对象功能受限；他们总是被认为是存活的和守护模式，不能被 join() 。因为无法检测外来线程的终结，它们永远不会被删除。



`Thread`类用于创建和管理线程。其构造函数的参数及其描述如下：

```python
class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
```

- **group**: （应设为None）- 此参数目前保留未来扩展使用，用于可能的`ThreadGroup`类实现。当前版本中，应始终传递`None`作为此参数的值。

- **target**: （默认为None）- 这是一个可调用对象，即当线程启动后将调用的函数。如果设为`None`，则新线程不会执行任何函数，仅简单地启动然后立即结束。常见的用法是传递一个函数名或是一个绑定方法的对象。

- **name**: （默认为"Thread-N"）- 设置线程的名字，其中"N"是一个递增的十进制数，用于生成唯一名称。自定义此参数可以帮助在日志记录或调试时更容易识别各个线程。

- **args**: （默认为()）- 一个元组，包含了传递给`target`函数的位置参数。允许你为线程任务指定具体的输入值。

- **kwargs**: （默认为{}）- 一个字典，包含了传递给`target`函数的关键字参数。这为函数调用提供了更多的灵活性，可以通过关键字指定参数值。

- **daemon**: （默认为None）- 此参数用于设定线程是否为守护线程（后台线程）。如果设为`True`，则当主线程结束时，无论守护线程是否还在运行，都会被强制终止。如果设为`False`或保持默认值`None`，则线程会正常执行，直到其任务完成。如果设为`None`，线程将继承创建它的线程的守护状态。这个参数是从Python 3.3版本开始加入的。



当子类化`Thread`并重写构造函数时，确保首先调用基类的构造函数`Thread.__init__()`，以正确初始化线程的基本属性。通过这些参数，你可以灵活地定义线程的行为，包括指定线程执行的任务、名称、传递给任务的参数，以及线程的守护状态。



### 方法与属性

- `start()`
  - 启动线程活动，使线程开始执行。
  - 只能被调用一次，重复调用会抛出 `RuntimeError`。
- `run()`
  - 线程活动的主要方法，可被子类重写以定义线程执行的具体任务。
  - 默认实现会调用构造时指定的 `target` 函数（如有提供），并传入 `args` 和 `kwargs`。
- `join(timeout=None)`
  - 阻塞调用线程，直到被调用线程结束或超时。
  - 若提供 `timeout` 参数，超时后方法返回，无论目标线程是否结束。
  - 要检测超时，需检查线程是否存活（使用 `is_alive()`）。
- `name`
  - 线程的名称，用于识别，可通过直接赋值修改。
  - 初始值由构造函数设定，格式如 "Thread-N"。
- `ident`
  - 线程的标识符，线程启动后为非零整数，线程未启动或结束后可能被复用。
- `native_id`
  - 线程的系统原生ID，线程启动后为非负整数，可用于全局唯一标识线程，直到线程终止。
- `is_alive()`
  - 判断线程是否仍在运行，`run()` 开始至结束期间返回 `True`。
- `daemon`
  - 布尔值，表示线程是否为守护线程。守护线程随着主线程结束而结束，须在 `start()` 之前设置。



### 创建Thread对象并传递回调函数

```python
import threading
import time


def my_function(arg1, arg2):
    time.sleep(2)
    print(f"线程 {threading.current_thread().name} 正在运行，参数为：{arg1}, {arg2}")


# 创建线程实例
my_thread = threading.Thread(target=my_function, args=(100, "World"), name="DemoThread")

# 设置为守护线程（可选）
# my_thread.daemon = True  # 设置True后，主线程结束，子线程也随之结束。

# 启动线程
my_thread.start()

print("主线程继续执行其他任务...")

# 如果需要，等待子线程结束
# my_thread.join()  # 使用join后，主线程会等待子线程结束，再执行后续代码。

print("所有任务完成。")
```



### 继承Thread类并重写run方法

```python
import threading
import time


class MyThread(threading.Thread):
    def __init__(self, arg1, arg2, name=None):
        super().__init__(name=name)
        self.arg1 = arg1
        self.arg2 = arg2

    def run(self):
        time.sleep(2)
        print(f"线程 {self.name} 正在运行，参数为：{self.arg1}, {self.arg2}")


# 创建线程实例
my_thread = MyThread(100, "World", name="DemoThread")

# 设置为守护线程（可选）
# my_thread.daemon = True  # 设置True后，主线程结束，子线程也随之结束。

# 启动线程
my_thread.start()

print("主线程继续执行其他任务...")

# 如果需要，等待子线程结束
# my_thread.join()  # 使用join后，主线程会等待子线程结束，再执行后续代码。

print("所有任务完成。")
```





## 互斥锁对象 Lock

原始锁是一个在锁定时不属于特定线程的同步基元组件。

原始锁处于 "锁定" 或者 "非锁定" 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， `acquire()` 和 `release()` 。

当状态为非锁定时， acquire() 将状态改为 锁定 并立即返回。当状态是锁定时， acquire() 将阻塞至其他线程调用 release() 将其改为非锁定状态，然后 acquire() 调用重置其为锁定状态并返回。 release() 只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 RuntimeError  异常。

锁同样支持With上下文管理协议。

当多个线程在 acquire() 等待状态转变为未锁定被阻塞，然后 release() 重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。

所有方法的执行都是原子性的。



`Lock` 用于实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。

```python
class threading.Lock
```



### 方法

以下是关于Python `threading` 模块中锁操作方法的无序列表描述：

- **`acquire(blocking=True, timeout=-1)`**
  - 可以阻塞或非阻塞地获得锁。
  - 当调用时参数 *blocking* 设置为 `True` （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 `True` 。
  - 在参数 *blocking* 被设置为 `False` 的情况下调用，将不会发生阻塞。如果调用时 *blocking* 设为 `True` 会阻塞，并立即返回 `False` ；否则，将锁锁定并返回 `True`。
  - 当浮点型 *timeout* 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 *timeout* 设定的秒数。*timeout* 参数被设置为 `-1` 时将无限等待。当 *blocking* 为 false 时，*timeout* 指定的值将被忽略。
  - 如果成功获得锁，则返回 `True`，否则返回 `False` (例如发生 *超时* 的时候)。
- **`release()`**
  - **功能**：释放已经获取的锁。这个方法可以在任何线程中调用，不单指获得锁的线程。
  - 当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。
  - 在未锁定的锁调用时，会引发`RuntimeError`异常。
  - 没有返回值。
- **`locked()`**
  - **目的**：检查锁当前是否被持有。
  - **返回**：锁被持有返回`True`，否则`False`。
  - **用途**：快速查询锁状态，不涉及获取或释放操作。

这些方法提供了基本的锁管理能力，确保线程间资源访问的同步与控制。



### 使用示例

```python
import threading
import time

# 创建一个Lock实例
lock = threading.Lock()

# 共享资源，此处为一个简单的计数器
counter = 0


def increment_counter(num_times):
    """
    一个模拟增加计数器的线程函数
    """
    global counter
    for _ in range(num_times):
        with lock:  # 使用with语句自动管理锁的获取与释放
            local_counter = counter
            local_counter += 1
            time.sleep(0.1)  # 模拟耗时操作，增加线程调度机会
            counter = local_counter
            print(f"Thread {threading.current_thread().name} incremented counter to {counter}")


# 创建并启动多个线程
threads = []
for i in range(3):
    t = threading.Thread(target=increment_counter, args=(2,))
    threads.append(t)
    t.start()

# 等待所有线程完成
for t in threads:
    t.join()

print(f"Final counter value: {counter}")


"""
Thread Thread-1 incremented counter to 1
Thread Thread-1 incremented counter to 2
Thread Thread-3 incremented counter to 3
Thread Thread-3 incremented counter to 4
Thread Thread-2 incremented counter to 5
Thread Thread-2 incremented counter to 6
Final counter value: 6
"""
```







## 递归锁对象 RLock

递归锁（Recursive Lock），也称为可重入锁（Reentrant Mutex），在多线程编程中扮演着重要的角色，其核心意义在于解决线程在递归调用或多次调用同一段加锁代码时可能出现的死锁问题。

重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 "所属线程" 和 "递归等级" 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。

若要锁定锁，线程调用其 acquire() 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 release() 方法。 acquire()/release() 对可以嵌套；只有最终 release() (最外面一对的 release() ) 将锁解开，才能让其他线程继续处理 acquire() 阻塞。

递归锁也支持 上下文管理协议。



`RLock `实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。

```python
class threading.RLock
```



### 方法

- `acquire`(*blocking=True*, *timeout=-1*)
  - 可以阻塞或非阻塞地获得锁。
  - 当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。
  - 当发起调用时将 *blocking* 参数设为真值，则执行与无参数调用时一样的操作，然后返回 `True`。
  - 当发起调用时将 *blocking* 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 `False`；在其他情况下，执行与无参数调用时一样的操作，然后返回 `True`。
  - 当发起调用时将浮点数的 *timeout* 参数设为正值时，只要无法获得锁，将最多阻塞 *timeout* 所指定的秒数。 如果已经获得锁则返回 `True`，如果超时则返回假值。

- `release`()
  - 释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。
  - 只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 RuntimeError 异常。
  - 没有返回值。



### 使用示例

```python
import threading

lock = threading.Lock()

lock.acquire()
print(f"第1次获取锁 -- {id(lock)}")
for i in range(3):
    lock.acquire()
    print(f"第2次获取锁 -- {id(lock)} -- {i}")
    lock.release()
lock.release()

"""
第1次获取锁 -- 20514816
(阻塞)
"""
```

以上使用互斥锁，会发生堵塞。如果使用递归锁，则不会出现阻塞。

```python
import threading

lock = threading.RLock()

lock.acquire()
print(f"第1次获取锁 -- {id(lock)}")
for i in range(3):
    lock.acquire()
    print(f"第2次获取锁 -- {id(lock)} -- {i}")
    lock.release()
lock.release()

"""
第1次获取锁 -- 29296640
第2次获取锁 -- 29296640 -- 0
第2次获取锁 -- 29296640 -- 1
第2次获取锁 -- 29296640 -- 2
"""
```



